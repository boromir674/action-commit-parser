name: CI Tests Action
on:
  workflow_call:
    inputs:
      test_matrix:
        description: 'JSON Object like {"test_data": [{from_ref?, to_ref?, expected_commits_array}, {...}]}; the Job Matrix: A JSON object of key (factors) mapping to arrays (of test cases to run).'
        required: true
        type: string

      # # TEST DATA: input
      # from_ref:
      #   description: 'Git Ref to start Commit Generation from'
      #   type: string
      #   required: false
      #   default: 'HEAD'
      # to_ref:
      #   description: 'Git Ref to end Commit Generation to'
      #   type: string
      #   required: false
      #   default: 'main'
      # # TEST DATA: expectations
      # expected_commits_array:
      #   description: 'The JSON array of commits generated from the git log.'
      #   required: true
      #   type: string
jobs:
  ### TEST Action in End-2-End Scenario, using Callable Test Workflows ###
  test_simple_case:
    uses: ./.github/workflows/_test_action.yml
    with:
      # TEST DATA: input refs with 2 commits in between -> yields 3 commits
      from_ref: fa4179f22acd503331d78f79e14324c3b4f05153  # v0.2.0
      to_ref: 6b8a0707f43c895a7a180caee41b0aeb0a6bf77e
      # TEST DATA: Expectations is JSON array of 3 commits
      expected_commits_array: '[{"message": "[NEW] Action Commit Parser v0.2.0 Release"},{"message": "build(docs): pin griffe to 0.40.1, to prevent just released broken built creash our CI Docs Build"},{"message": "ci: reproduce docs build env using statically compiled pinned requirements"}]'

  test_job_matrix:
    # runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(inputs.test_matrix) }}
    # steps:
    #   # SANITY CHECKs
    #   - name: Access Parsed Data
    #     run: |
    #       echo '${{ matrix.test_data.from_ref }}'
    #       echo '${{ matrix.test_data.to_ref }}'
    #       echo '${{ matrix.test_data.expected_commits_array }}'

    #   - name: Print Test Case Data, such business logic inputs and expectations
    #     run: echo '${{ toJSON(matrix.test_data) }}' | jq

    #   # Run Test Case: GIVEN, WHEN, THEN
    #   - name: 'Run End 2 End Test Case: GIVEN, WHEN, THEN'
    # uses: ./.github/workflows/_test_action.yml
    # with:
    #   from_ref: ${{ matrix.test_data.from_ref }}
    #   to_ref: ${{ matrix.test_data.to_ref }}
    #   expected_commits_array: ${{ matrix.test_data.expected_commits_array }}

    runs-on: ubuntu-latest
    steps:
      # SANITY CHECKs
      - name: Print Test Data
        run: |
          echo '${{ matrix.test_data.from_ref }}'
          echo '${{ matrix.test_data.to_ref }}'
          echo '${{ toJSON(matrix.test_data.expected_commits_array) }}'
      - run: echo '${{ toJSON(matrix.test_data) }}' | jq

      # GIVEN a git history and 2 Refs
      - name: Checkout This Repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      # WHEN the Commit Parser Action is run between the 2 Refs
      - name: Run Commit Parser Action between from ${{ inputs.from_ref }} to ${{ inputs.to_ref }} Refs
        id: test_commit_parser
        uses: boromir674/action-commit-parser@dev
        # uses: ./  # Uses an action in the root directory
        with:
          from_ref: ${{ matrix.test_data.from_ref }}
          to_ref: ${{ matrix.test_data.to_ref }}

      # THEN the Action should output the expected commits
      - name: Assert Action Output
        run: |
          echo "[DEBUG] Raw Output:"
          echo '${{ steps.test_commit_parser.outputs.commits_array }}'
          echo
          echo "[DEBUG] JSON Output:"
          echo '${{ steps.test_commit_parser.outputs.commits_array }}' | jq
          echo

          echo "[DEBUG] Raw Expected Output:"
          echo '${{ matrix.test_data.expected_commits_array }}'
          echo
          echo "[DEBUG] JSON Expected Output:"
          echo '${{ toJSON(matrix.test_data.expected_commits_array) }}' | jq
          echo

          echo "[DEBUG] Comparing Outputs with jq:"
          jq --exit-status --argjson expected '${{ toJSON(matrix.test_data.expected_commits_array) }}' '$expected == .' <<< '${{ steps.test_commit_parser.outputs.commits_array }}'

      # Should be safe as long as message does not have single or double quotes
      # TODO escape single-quotes
      - name: Test different commands for storing JSON output, GITHUB_ENV variable
        run: |
          echo 'COMMITS_JSON_ARRAY=${{ steps.test_commit_parser.outputs.commits_array }}'
          # echo "COMMITS_JSON_ARRAY=${{ steps.test_commit_parser.outputs.commits_array }}"
      
      - name: Verify Bash Substitutions work, with jq -r flag
        run: |
          echo "HEADER

          $(echo [\"a \'single-quoted\' AND a \\\"double-quoted\\\" term in the 1st line\", \"and something else in the 2nd line\", \"and a line with 1 double-quote: \\\"\", \"and a line with one single-quote: \'\"] | jq -r '.[]')
       
          FOOTER"

      # SANITY CHECKs
      - name: Test converting to JSON array of messages
        run: echo '${{ steps.test_commit_parser.outputs.commits_array }}' | jq -c '[.[].message]'
      
      - name: Test converting to single-line BASH array of double-quoted messages
        run: echo '${{ steps.test_commit_parser.outputs.commits_array }}' | jq -c '.[].message'

      - name: Store JSON Array of objects as JSON Array of strings, in a GITHUB_ENV Variable
        run: echo COMMITS_ARRAY=$(echo '${{ steps.test_commit_parser.outputs.commits_array }}' | jq -c '[.[].message]') >> $GITHUB_ENV

      # TEST AWK processing
      - name: Test awk processing works as epexcted
        run: echo '${{ env.COMMITS_ARRAY }}' | jq -r '.[]' | awk '{print "- " $0}'

      # SANITY CHECKs
      - name: Read the Stored Output JSON from GITHUB_ENV
        run: echo "${COMMITS_ARRAY}" | jq

      - name: Read Output JSON from GITHUB_ENV template, between double-quotes GITHUB_ENV
        run: echo "${{ env.COMMITS_ARRAY }}" | jq

      - name: Read Output JSON from GITHUB_ENV template, between single-quotes GITHUB_ENV
        run: echo '${{ env.COMMITS_ARRAY }}' | jq
